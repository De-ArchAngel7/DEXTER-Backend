from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import structlog
from dataclasses import dataclass
from enum import Enum

logger = structlog.get_logger()

class StrategyType(Enum):
    """Trading strategy types"""
    SCALPING = "SCALPING"
    SWING = "SWING"
    LONG_TERM = "LONG_TERM"
    MOMENTUM = "MOMENTUM"
    MEAN_REVERSION = "MEAN_REVERSION"
    ARBITRAGE = "ARBITRAGE"

class RiskLevel(Enum):
    """Risk level enumeration"""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"

@dataclass
class StrategyConfig:
    """Configuration for a trading strategy"""
    name: str
    strategy_type: StrategyType
    risk_level: RiskLevel
    max_position_size: float
    stop_loss_percentage: float
    take_profit_percentage: float
    max_hold_time: timedelta
    min_confidence_threshold: float
    max_daily_trades: int
    enabled: bool = True

@dataclass
class StrategySignal:
    """Signal generated by a trading strategy"""
    symbol: str
    action: str  # 'BUY', 'SELL', 'HOLD'
    confidence: float
    reasoning: str
    strategy_name: str
    timestamp: datetime
    price_target: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

class BaseStrategy:
    """Base class for all trading strategies"""
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.name = config.name
        self.strategy_type = config.strategy_type
        self.risk_level = config.risk_level
        
    async def generate_signal(self, market_data: Dict[str, Any], 
                            ai_insight: Dict[str, Any]) -> StrategySignal:
        """Generate trading signal - to be implemented by subclasses"""
        raise NotImplementedError
        
    def calculate_position_size(self, available_capital: float, 
                              confidence: float) -> float:
        """Calculate position size based on strategy and confidence"""
        base_size = available_capital * self.config.max_position_size
        
        # Adjust based on confidence
        confidence_multiplier = confidence / 100.0
        
        # Adjust based on risk level
        risk_multiplier = {
            RiskLevel.LOW: 0.5,
            RiskLevel.MEDIUM: 1.0,
            RiskLevel.HIGH: 1.5
        }[self.risk_level]
        
        return base_size * confidence_multiplier * risk_multiplier

class ScalpingStrategy(BaseStrategy):
    """Scalping strategy for quick, small profits"""
    
    def __init__(self):
        config = StrategyConfig(
            name="Scalping",
            strategy_type=StrategyType.SCALPING,
            risk_level=RiskLevel.HIGH,
            max_position_size=0.05,  # 5% max position
            stop_loss_percentage=0.02,  # 2% stop loss
            take_profit_percentage=0.03,  # 3% take profit
            max_hold_time=timedelta(hours=1),
            min_confidence_threshold=70.0,
            max_daily_trades=100
        )
        super().__init__(config)
        
    async def generate_signal(self, market_data: Dict[str, Any], 
                            ai_insight: Dict[str, Any]) -> StrategySignal:
        """Generate scalping signal based on short-term price movements"""
        
        # Get current price and recent price data
        current_price = market_data.get('price', 0)
        price_change = market_data.get('change_percent', 0)
        
        # Get AI recommendation and confidence
        ai_recommendation = ai_insight.get('trading_recommendation', 'HOLD')
        ai_confidence = ai_insight.get('confidence_score', 0)
        
        # Scalping logic: Look for quick momentum opportunities
        if ai_confidence >= self.config.min_confidence_threshold:
            if ai_recommendation in ['BUY', 'STRONG_BUY'] and price_change > 0.5:
                action = 'BUY'
                confidence = min(ai_confidence + 10, 100)
                reasoning = f"Scalping: Strong upward momentum ({price_change:.2f}%) with AI confirmation"
                
            elif ai_recommendation in ['SELL', 'STRONG_SELL'] and price_change < -0.5:
                action = 'SELL'
                confidence = min(ai_confidence + 10, 100)
                reasoning = f"Scalping: Strong downward momentum ({price_change:.2f}%) with AI confirmation"
                
            else:
                action = 'HOLD'
                confidence = ai_confidence
                reasoning = f"Scalping: Insufficient momentum for quick trade"
        else:
            action = 'HOLD'
            confidence = ai_confidence
            reasoning = f"Scalping: AI confidence below threshold ({ai_confidence:.1f}% < {self.config.min_confidence_threshold}%)"
        
        # Calculate price targets
        price_target = None
        stop_loss = None
        take_profit = None
        
        if action == 'BUY':
            price_target = current_price * 1.03  # 3% target
            stop_loss = current_price * 0.98     # 2% stop loss
            take_profit = current_price * 1.03   # 3% take profit
        elif action == 'SELL':
            price_target = current_price * 0.97  # 3% target
            stop_loss = current_price * 1.02     # 2% stop loss
            take_profit = current_price * 0.97   # 3% take profit
        
        return StrategySignal(
            symbol=market_data.get('symbol', ''),
            action=action,
            confidence=confidence,
            reasoning=reasoning,
            strategy_name=self.name,
            timestamp=datetime.now(),
            price_target=price_target,
            stop_loss=stop_loss,
            take_profit=take_profit
        )

class StrategyManager:
    """Manages multiple trading strategies and coordinates their signals"""
    
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        
        # Initialize default strategies
        self._initialize_strategies()
        
    def _initialize_strategies(self):
        """Initialize default trading strategies"""
        self.strategies['scalping'] = ScalpingStrategy()
        
    async def generate_consolidated_signal(self, symbol: str, 
                                         market_data: Dict[str, Any],
                                         ai_insight: Dict[str, Any]) -> StrategySignal:
        """Generate consolidated trading signal from all strategies"""
        
        # Get signals from all strategies
        strategy_signals = []
        for strategy_name, strategy in self.strategies.items():
            if strategy.config.enabled:
                try:
                    signal = await strategy.generate_signal(market_data, ai_insight)
                    strategy_signals.append(signal)
                except Exception as e:
                    logger.error(f"Error generating signal for {strategy_name}: {e}")
                    continue
        
        if not strategy_signals:
            return StrategySignal(
                symbol=symbol,
                action='HOLD',
                confidence=0.0,
                reasoning="No strategy signals available",
                strategy_name="consolidated",
                timestamp=datetime.now()
            )
        
        # Consolidate signals
        consolidated_signal = self._consolidate_signals(strategy_signals)
        
        return consolidated_signal
        
    def _consolidate_signals(self, signals: List[StrategySignal]) -> StrategySignal:
        """Consolidate multiple strategy signals into one"""
        
        # Count actions
        action_counts = {'BUY': 0, 'SELL': 0, 'HOLD': 0}
        total_confidence = 0
        
        for signal in signals:
            action_counts[signal.action] += 1
            total_confidence += signal.confidence
        
        # Determine consolidated action
        if action_counts['BUY'] > action_counts['SELL'] and action_counts['BUY'] > action_counts['HOLD']:
            action = 'BUY'
        elif action_counts['SELL'] > action_counts['BUY'] and action_counts['SELL'] > action_counts['HOLD']:
            action = 'SELL'
        else:
            action = 'HOLD'
        
        # Calculate consolidated confidence
        avg_confidence = total_confidence / len(signals) if signals else 0
        
        # Boost confidence if multiple strategies agree
        agreement_boost = 0
        if action == 'BUY' and action_counts['BUY'] > 1:
            agreement_boost = 10
        elif action == 'SELL' and action_counts['SELL'] > 1:
            agreement_boost = 10
            
        final_confidence = min(100, avg_confidence + agreement_boost)
        
        # Create consolidated reasoning
        reasoning = f"Consolidated signal from {len(signals)} strategies: "
        reasoning += f"BUY({action_counts['BUY']}), SELL({action_counts['SELL']}), HOLD({action_counts['HOLD']})"
        
        return StrategySignal(
            symbol=signals[0].symbol if signals else '',
            action=action,
            confidence=final_confidence,
            reasoning=reasoning,
            strategy_name="consolidated",
            timestamp=datetime.now()
        )
